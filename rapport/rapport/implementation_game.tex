\section{Implementation of Game Software}

This section deals with the implementation of the modules discussed in the design section.

\subsection{Hardware Abstraction Layer Implementation}
As mentioned before, the hardware layer is fairly thin as only three modules are needed for our game.

\paragraph{SPI module}
The setup\_SPI\_master() function  configures the hardware SPI module the eZ8 development board to run at max speed as a master.
The write\_spi() pulls the slave pin low, signaling the start of a transmission and places its argument in the SPI data register
which immediatly starts transferring the data. It then waits until the transmission is complete and returns.

\paragraph{Timerlib}
The set\_timer() functions takes arguments to configure what timer to enable, what period the timer
should be set to, the priority, and what function should be called when the interrupt occurs. Currently
only one timer can be enabled and the timer select argument is simply ignored, so is the priority. 
The function calculates the needed reload values for the timer and enables TIMER0. The interrupt vector
is set to call a function which immediately calls the function passed as an argument using a function pointer.

\paragraph{ADC input}
the ADC module is fairly simple. The setup\_joystick() function takes
no arguments and configures the PB0 pin on the eZ8 development board for its alternate ADC function.
The read\_joystick() function simply returns the most significant 8 bits of the current ADC sample.

\subsection{API Layer Implementation}
The API layer uses the functions provided by the hardware abstraction layer to present additional functionality to the application
layer.

\paragraph{Input Module}
The input module manages and presents a global array to the application layer. This global array contains the state of all inputs
and it is updated every time get\_input() is called. The array indexing is managed with an enumeration, such that
additions to the array do not destroy existing dependencies. The array is global because almost every module in the
application layer needs access to the current keystate or joystick value. The input array is only updated by the 
input module. Before being able to utilize joystick input, an application must first call setup\_input() which 
makes sure that the joystick ADC pins are enabled.

\paragraph{Sound Module}
The sound module contains different named sounds that can be played by calling the play\_sound() function.
To be able to play sound, the SPI module must first be setup and so the sound module includes a
function for enabling the sound.

\paragraph{Math module}
The math module contains a macro for the cosine function and 8.8 fixed point math. Its only real
function is the sin() function. This takes an argument in 512-degrees and returns the
sine value of the angle from a lookup-table that was generated by an excel macro given in
the first weeks exercises.

\paragraph{Graphics Module}
The graphics module utilizes the UART on the eZ8 board to send ANSI escape codes to a terminal on a PC.
The gotoxy(),  
